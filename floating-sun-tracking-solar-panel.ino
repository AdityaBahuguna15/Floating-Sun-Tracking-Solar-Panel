/*
  Sketch generated by the Arduino IoT Cloud Thing "A-TEK Code"
  https://create.arduino.cc/cloud/things/...

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  float ActualSPVolt;
  CloudColoredLight LED;
  int batt_avg;
*/

#include <Servo.h>
#include "thingProperties.h" // This file is generated by Arduino IoT Cloud
#include <WiFiNINA.h>
#include <utility/wifi_drv.h>
#include <BQ24195.h>

//Declare two servos
Servo servo_updown;
Servo servo_leftright;

//Assign analog pins
int ldrtop = A2;        // Top LDR
int ldrbottom = A1;     // Bottom LDR
int ldrleft = A3;       // Left LDR
int ldrright = A4;      // Right LDR
int SPVolt = A6;        // Solar Panel Voltage Reader

//Initialize varaibles
int top = 0;            //Sensor values
int bottom = 0;
int left = 0;
int right = 0;
int threshold = 5;      //minimum amount of error needed to change angle
int vpos = 90;          //positioning of motors
int hpos = 90;
int n = 1;
int new_batt = 0;
int batt_total = 0;

//define Battery Voltage variables
float rawADC;           //unprocessed ADC value
float voltADC;          //ADC converted into voltage
float voltBat;          //calculated voltage on battery

//define the resistor values in the voltage divider(INBUILT)
int R1 = 330000;        // resistor between battery terminal and SAMD pin PB09
int R2 = 1000000;       // resistor between SAMD pin PB09 and ground

int max_Source_voltage; // upper source voltage for the battery

// define voltage at which battery is full/empty
float batteryFullVoltage = 4.2;      //upper voltage limit for battery
float batteryEmptyVoltage = 3.3;     //lower voltage limit for battery
float batteryCapacity = 1;           //set battery capacity in Ah

//define Solar Panel Voltage variables
float SolarV;
float SVoltage;

//Resistor values in Voltage divider
int R3 = 100000;
int R4 = 33000;

void setup() {
  //Initialize serial and wait for port to open:
  Serial.begin(9600);
  servo_leftright.attach(4);  //Servo horizontal attached to pin 4
  servo_updown.attach(5);     //Servo vertical attached to pin 5

  //Defined in thingProperties.h
  initProperties();

  //Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);

  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();

  //For Battery Voltage
  analogReference(AR_DEFAULT);      // the upper value of ADC is set to 3.3V
  //analogReadResolution(12);       // this will give us 4096 (2^12) levels on the ADC

  //configure BQ24195 PMIC
  PMIC.begin();                                         // start the PMIC I2C connection
  PMIC.enableBoostMode();                               // boost battery output to 5V
  PMIC.setMinimumSystemVoltage(batteryEmptyVoltage);    // set the minimum battery output to 3.5V
  PMIC.setChargeVoltage(batteryFullVoltage);            // set battery voltage at full charge
  PMIC.setChargeCurrent(batteryCapacity * 10);          // set battery current to C/2 in amps
  PMIC.enableCharge();                                  // enable charging of battery

  // The formula for calculating the output of a voltage divider is
  // Vout = (Vsource * R2)/(R1 + R2)
  // Consider that 3.3V is the maximum that can be applied to Vout then the maximum source voltage is calculated as
  max_Source_voltage = (3.3 * (R1 + R2)) / R2;

  //Define RGB
  WiFiDrv::pinMode(25, OUTPUT); //define green pin
  WiFiDrv::pinMode(26, OUTPUT); //define red pin
  WiFiDrv::pinMode(27, OUTPUT); //define blue pin
}

void loop() {
  ArduinoCloud.update();

  //Storing Analog values
  top = analogRead(ldrtop);
  bottom = analogRead(ldrbottom);
  left = analogRead(ldrleft);
  right = analogRead(ldrright);

  //Difference (error)
  int tbdiff = (top - bottom) / 2;
  int lrdiff = (left - right) / 2;
  int step = 5;

  //up-down movement of solar tracker
  if (abs(tbdiff) >= threshold) {   // Change position if light difference is big
    if (tbdiff > 0) {
      vpos += 1;
    } else if (tbdiff < 0) {
      vpos -= 1;
    }
  }
  vpos = constrain(vpos, 5, 175);
  servo_updown.write(vpos);
  Serial.println(vpos);

  //left-right movement of solar tracker
  if (abs(lrdiff) >= threshold) {   // Change position if light difference is big
    if (vpos <= 90) {
      if (lrdiff > 0) {
        hpos += 1;
      } else {
        hpos -= 1;
      }
    } else if (vpos > 90) {
      if (lrdiff > 0) {
        hpos -= 1;
      } else {
        hpos += 1;
      }
    }
  }
  hpos = constrain(hpos, 5, 175);
  servo_leftright.write(hpos);
  Serial.println(hpos);

  //Battery Voltage and Percentage
  if (n % 100 == 0) {
    rawADC = analogRead(ADC_BATTERY);               //the value obtained directly at the PB09 input pin
    voltADC = rawADC * (3.3 / 1023.0);              //convert ADC value to the voltage read at the pin
    voltBat = voltADC * (max_Source_voltage / 3.3); //we cannot use map since it requires int inputs/outputs

    //custom float friendly map function
    new_batt = (voltBat - batteryEmptyVoltage) * (100) / (batteryFullVoltage - batteryEmptyVoltage);
    batt_total = batt_total + new_batt;             //adds all battery % across 10 values
  }
  if (n % 1000 == 0) {
    batt_avg = batt_total / 10;                     //divides the 10 values by 10 to find avg battery
    batt_total = 0;                                 //Resets the battery sum
  }
  n++;

  //With the diode, the solar panel voltage:
  SolarV = analogRead(SPVolt);
  SVoltage = SolarV * (4 / 1023.0);
  ActualSPVolt = ((SVoltage - 0.2) * (9.07 - 0.09)) / (4 - 0.2) + 0.09;
  Serial.println(SVoltage);
  Serial.println(ActualSPVolt);

  //LDR Print
  Serial.print("LDRTop: ");
  Serial.print(top);
  Serial.print(" LDRBot: ");
  Serial.print(bottom);
  Serial.print(" LDRLeft: ");
  Serial.print(left);
  Serial.print(" LDRRight: ");
  Serial.print(right);
  Serial.println();

  delay(10);
}

/*
  Since LED is READ_WRITE variable, onLEDChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onLEDChange() {
  // Add your code here to act upon LED change
  uint8_t r, g, b;
  LED.getValue().getRGB(r, g, b);
  if (LED.getSwitch() == true) {
    WiFiDrv::analogWrite(25, r);
    WiFiDrv::analogWrite(26, g);
    WiFiDrv::analogWrite(27, b);
    delay(1000); // Adjust the delay as needed
  } else {
    WiFiDrv::analogWrite(25, 0);
    WiFiDrv::analogWrite(26, 0);
    WiFiDrv::analogWrite(27, 0);
  }
}